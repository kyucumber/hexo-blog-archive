<!DOCTYPE html><html lang="kr"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>자바 기반 면접 질문 정리 | Devlog</title><link rel="stylesheet" href="/libs/spoqa-han-sans-kr/css/SpoqaHanSans-kr.css"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/etc/interview/"/>
<meta name="description" content="String, StringBuilder, StringBuffer 차이 String  String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이…">
<meta name="keywords" content="Interview">
<meta property="og:type" content="article">
<meta property="og:title" content="자바 기반 면접 질문 정리">
<meta property="og:url" content="http://yoursite.com/etc/interview/">
<meta property="og:site_name" content="Devlog">
<meta property="og:description" content="String, StringBuilder, StringBuffer 차이 String  String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이…">
<meta property="og:locale" content="kr">
<meta property="og:image" content="http://yoursite.com/images/data/graph.png">
<meta property="og:updated_time" content="2018-06-02T12:21:48.384Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="자바 기반 면접 질문 정리">
<meta name="twitter:description" content="String, StringBuilder, StringBuffer 차이 String  String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이…">
<meta name="twitter:image" content="http://yoursite.com/images/data/graph.png"><meta property="article:author" content="https://www.facebook.com/xmfpes"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-06-02 21:30:00"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="KyuNam"><link rel="icon" href="/images/internet.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Devlog"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/internet.png" alt="Devlog"><span class="menu__item__link--brand__label">Devlog</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">자바 기반 면접 질문 정리</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-06-02T12:30:00.000Z" itemprop="datePublished">2018-06-02 21:30:00</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Interview/">Interview</a></div></div><div class="article__contents"><img src="/images/data/graph.png"/><h2 id="String-StringBuilder-StringBuffer-차이"><a href="#String-StringBuilder-StringBuffer-차이" class="headerlink" title="String, StringBuilder, StringBuffer 차이"></a>String, StringBuilder, StringBuffer 차이</h2><ul>
<li>String</li>
</ul>
<p>String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이 존재한다. 하지만 JDK 1.5 이후부터는 컴파일 타임에 StringBuilder로 변경한다고 한다.</p>
<ul>
<li>StringBuilder</li>
</ul>
<p>String에서 + 등으로 문자열 등을 concat하는 연산이 많은 경우 사용하는것이 좋다. 기존 String 문자들을 concat하는 경우 매번 새로운 String 인스턴스를 사용하기 때문에 성능상의 이슈 존재(JDK 1.5버전 부터는 내부적으로 StringBuilder를 이용하도록 변경되긴 했다.)</p>
<ul>
<li>StringBuffer</li>
</ul>
<p>StringBuffer는 Builder와 비교해서 thread-safe하다. (멀티 스레드 환경에서 동기화의 지원 여부가 다름.) 내부적으로 append 등 모든 메소드에 대해 synchronized 키워드가 붙어있다.</p>
<h2 id="Comparable-Comparator-차이"><a href="#Comparable-Comparator-차이" class="headerlink" title="Comparable, Comparator 차이"></a>Comparable, Comparator 차이</h2><p>정렬을 위해서 사용하는 인터페이스들인데 Comparable 인터페이스는 정렬 기준을 설정할 클래스가 직접 상속해 compareTo 메소드를 오버라이딩 해야 하며, Comparator는 직접 구현해서 Arrays.sort 같은 정렬 메소드에 인자로 넘겨 정렬 기준을 직접 설정해 줄 수 있다. </p>
<h2 id="JVM의-구조"><a href="#JVM의-구조" class="headerlink" title="JVM의 구조"></a>JVM의 구조</h2><p>JRE는 JVM과 Java API로 구성되어 있다.</p>
<p>자바 바이트코드는 JRE 위에서 동작하며, JRE는 JVM과 Java API로 구성되어 있다.</p>
<p>그 중 JVM은 자바 어플리케이션을 클래스 로더를 통해 읽어서 바이트코드를 해석하고 자바 API와 함께 실행하는 가장 중요한 역할을 담당하고 있다.</p>
<p>자바의 코드가 수행되는 과정은 Java Source(.java 파일)가 javac에 의해 Java Byte Code(.class 파일)로 변경되고 JVM의 클래스 로더가 컴파일된 자바 바이트코드를 런타임 데이터 영역에 로드하고 실행 엔진이 자바 바이트 코드를 수행하는 과정으로 이루어진다.</p>
<p><img src="assets/image-20180602145758293.png" alt="image-20180602145758293"></p>
<blockquote>
<p> 클래스 로더(Class Loader)</p>
</blockquote>
<p>자바는 컴파일타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더이다. </p>
<blockquote>
<p> 런타임 데이터 영역(Runtime Data Areas)</p>
</blockquote>
<p>VM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 아래의 6가지 영역으로 나눌 수 있다.</p>
<p>스레드 별 하나씩 생성되는 영역</p>
<ul>
<li>PC Register</li>
</ul>
<p>스레드가 시작 될 때 생성, 현재 수행중인 JVM의 명령의 주소를 가진다.</p>
<ul>
<li>JVM Stack</li>
</ul>
<p>스레드 시작 시 생성, 스택 프레임을 저장하는 스택</p>
<p><strong>Stack Frame</strong></p>
<p><em>**</em>스택 프레임은 JVM 내에서 메서드가 수행될 때마다 하나의 스택 프레임이 생성되어 해당 스레드의 JVM 스택에 추가되고 메서드가 종료되면 스택 프레임이 제거된다. 각 스택 프레임은 지역 변수 배열(Local Variable Array), 피연산자 스택(Operand Stack), 현재 실행 중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스를 갖는다. 지역 변수 배열, 피연산자 스택의 크기는 컴파일 시에 결정되기 때문에 스택 프레임의 크기도 메서드에 따라 크기가 고정된다.</p>
<p><strong>지역 변수 배열</strong></p>
<p>0부터 시작하는 인덱스를 가진 배열이다. 0은 메서드가 속한 클래스 인스턴스의 this 레퍼런스이고, 1부터는 메서드에 전달된 파라미터들이 저장되며, 메서드 파라미터 이후에는 메서드의 지역 변수들이 저장된다.</p>
<p><strong>피연산자 스택</strong></p>
<p>메서드의 실제 작업 공간이다. 각 메서드는 피연산자 스택과 지역 변수 배열 사이에서 데이터를 교환하고, 다른 메서드 호출 결과를 추가하거나(push) 꺼낸다(pop). 피연산자 스택 공간이 얼마나 필요한지는 컴파일할 때 결정할 수 있으므로, 피연산자 스택의 크기도 컴파일 시에 결정된다.</p>
<ul>
<li>Native Method Stack</li>
</ul>
<p>자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다. 즉, JNI(Java Native Interface)를 통해 호출하는 C/C++ 등의 코드를 수행하기 위한 스택으로, 언어에 맞게 C 스택이나 C++ 스택이 생성된다.</p>
<p>모든 스레드가 공유하는 영역</p>
<ul>
<li>Heap</li>
</ul>
<p>인스턴스 또는 객체를 저장하는 공간으로 가비지 컬렉션 대상이다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다. 힙 구성 방식이나 가비지 컬렉션 방법 등은 JVM 벤더의 재량이다.</p>
<ul>
<li>Method</li>
</ul>
<p>메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 정보, Static 변수, 메서드의 바이트코드 등을 보관한다.</p>
<p>크게 코드 캐시 영역과 PermGen 영역으로 나눌 수 있는데 코드 캐시 영역은 캐시 영역은 컴파일 된 코드를 저장하는 데 사용하고 <code>PermGen은 Deprecated되고 Metaspace 영역으로 변경</code>되었다. Metaspace는 클래스 메타 데이터를 native 메모리에 저장하고 메모리가 부족할 경우 이를 자동으로 늘려준다.</p>
<ul>
<li>Runtime Constant Pool</li>
</ul>
<p>각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.</p>
<blockquote>
<p> 실행 엔진(Executiontion Engine)</p>
</blockquote>
<p>클래스 로더를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 실행된다. 실행 엔진은 자바 바이트코드를 명령어 단위로 읽어서 실행한다. CPU가 기계 명령어을 하나씩 실행하는 것과 비슷하다. 바이트코드의 각 명령어는 1바이트짜리 OpCode와 추가 피연산자로 이루어져 있으며, 실행 엔진은 하나의 OpCode를 가져와서 피연산자와 함께 작업을 수행한 다음, 다음 OpCode를 수행하는 식으로 동작한다.</p>
<p>참고 <a href="https://d2.naver.com/helloworld/1230" target="_blank" rel="noopener">Naver d2 JVM Internal </a></p>
<h2 id="Override-Overload"><a href="#Override-Overload" class="headerlink" title="Override / Overload"></a>Override / Overload</h2><p>Overloading은 함수의 이름은 같으나 반환 타입이나 인자의 갯수, 인자의 타입이 다른 경우</p>
<p>Overriding 부모 클래스의 메소드를 자식 클래스에서 재정의 하는 것, 인터페이스의 메소드를 구현하는 경우</p>
<h2 id="LinkedList와-ArrayList의-차이"><a href="#LinkedList와-ArrayList의-차이" class="headerlink" title="LinkedList와 ArrayList의 차이"></a>LinkedList와 ArrayList의 차이</h2><p>ArrayList는 검색에 유리한 구조, 삽입 삭제가 자주 일어나면 LinkedList를 사용하는것이 낫다.</p>
<p>ArrayList는 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해 아래와 같이 임시 배열을 생성해 데이터를 복사 하는 방법을 사용 하고 있기 때문에 삽입 삭제시 많은 복사가 일어나기 때문.</p>
<h2 id="Abstract-Class-Interface-차이점"><a href="#Abstract-Class-Interface-차이점" class="headerlink" title="Abstract Class, Interface 차이점"></a>Abstract Class, Interface 차이점</h2><p>추상 클래스는 상속을 통해 부모 클래스의 기능을 이용, 확장하기 위해 제공되며 다중 상속이 불가능하다.</p>
<p>인터페이스는 빈 껍데기 형태로 구현할 메소드를 정의하고, 강제해서 서브클래스들에 같은 동작을 보장하기 위해 제공되며 다중 상속이 가능하다. 자바 8 부터 인터페이스에도 default 메소드 구현이 가능하다.</p>
<h2 id="Class와-Instance-Object"><a href="#Class와-Instance-Object" class="headerlink" title="Class와 Instance, Object"></a>Class와 Instance, Object</h2><p>객체는 식별가능한 그 무엇을 말하고 인스턴스는 클래스를 통해 생성된 객체 ex) …자동차 설계도 그 설계도로 만들어진 자동차?</p>
<p>객체는 클래스의 타입으로 선언되었을 때를 의미하며 그 객체가 메모리에 올라가서 실제 사용되면 인스턴스?</p>
<h2 id="프로세스와-스레드의-차이"><a href="#프로세스와-스레드의-차이" class="headerlink" title="프로세스와 스레드의 차이"></a>프로세스와 스레드의 차이</h2><p>몰라;; 내가 어떻게 알아</p>
<h2 id="HTTP-Request-body-header"><a href="#HTTP-Request-body-header" class="headerlink" title="HTTP Request, body, header"></a>HTTP Request, body, header</h2><p>몰라</p>
<h2 id="TCP와-UDP의-차이점"><a href="#TCP와-UDP의-차이점" class="headerlink" title="TCP와 UDP의 차이점"></a>TCP와 UDP의 차이점</h2><p>TCP와 UDP는 둘다 Transport 계층의 프로토콜로 데이터 전달을 위한 프로토콜.</p>
<p>TCP는 데이터의 정확한 전달을 중시한다. 3way handshaking을 통해 커넥션을 먼저 연결하고, 커넥션이 맺어진 이후에 데이터를 전송할 수 있다. 데이터 전송이 끝나면 4 way handshaking을 통해 커넥션을 종료한다.</p>
<p>신뢰성 있는 연결 보장의 차이. TCP는 3 way handshaking을 통해 서로 커넥션이 연결된 상태에서 통신을 시작한다. 연결 종료시에도 4 way handshaking을 통해 연결 종료.</p>
<p>UDP의 경우에는 TCP에서 지원하는 데이터 재전송이나 커넥션 연결 등을 생략하기 때문에 전송 과정에서 데이터의 손실이 발생할 수 있다. </p>
<p>UDP 프로토콜은 VoIP와 같은 음성 서비스, 동영상 스트리밍 등에 사용한다.</p>
<h2 id="Java의-접근-제어자"><a href="#Java의-접근-제어자" class="headerlink" title="Java의 접근 제어자"></a>Java의 접근 제어자</h2><p><strong>public</strong> 접근 제한이 없다.</p>
<p><strong>protected :</strong> 서브 클래스에서만 접근 가능</p>
<p><strong>default :</strong> 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지 내에서만 접근이 가능</p>
<p><strong>private :</strong> 자기 자신, 클래스 내부에서만 접근이 가능</p>
<h2 id="Java-Garbage-Collection"><a href="#Java-Garbage-Collection" class="headerlink" title="Java Garbage Collection"></a>Java Garbage Collection</h2><p>C++에서 new나 delete를 통해 메모리를 명시적으로 해제했지만 Java에서는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않고 가비지 컬렉터(Garbage Collector)가 이 역할을 대신한다.</p>
<p>더 이상 사용하지 않는 객체를 찾아서 지우는 역할을 하는것이 GC 이다.</p>
<p>Garbage Collection을 실행하면 JVM이 일시적으로 어플리케이션 실행을 멈추는데 이를 <code>stop-the-world</code> 라 한다.</p>
<p>stop-the-world가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다. GC 작업을 완료한 이후에야 중단했던 작업을 다시 시작한다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개의 경우 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것이다.</p>
<p>GC는 아래의 두가지 가설을 토대로 만들어졌다.</p>
<ul>
<li>대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다.</li>
<li>오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.</li>
</ul>
<p>이러한 가설을 ‘weak generational hypothesis’라 한다. 이 가설의 장점을 최대한 살리기 위해서 HotSpot VM에서는 크게 2개로 물리적 공간을 나누었다. 둘로 나눈 공간이 Young 영역과 Old 영역이다.</p>
<p>영역별 데이터 흐름은 아래와 같다.</p>
<p><img src="assets/image-20180602160808763.png" alt="image-20180602160808763"></p>
<p>위의 Permanenet Generation 영역은 Method 영역에 포함된 부분이고.. Java 8부터 MetaSpace 영역으로 바뀌었다고 한다. 위 그림과 동일하게 적용되는지는 모르겠다. (PermGen 영역에서 일어나는 GC도 Major GC에 포함된다.)</p>
<blockquote>
<p>Young 영역</p>
</blockquote>
<p>새롭게 생성된 데이터 대부분이 Young Generation에 위치하며 여기서 객체가 할당 해제되는 경우 Minor GC가 발생했다고 한다.</p>
<ul>
<li>Eden 영역</li>
<li>Survivor 영역(2개)</li>
</ul>
<p>으로 나뉘며, Eden에서 살아남은 객체는 Survivor 으로 보내고, Survivor영역이 가득 차면 다른 Survivor 영역으로 보낸다. 이 과정에서 살아남은 객체는 Old 영역으로 이동하게 된다.</p>
<blockquote>
<p>Old 영역</p>
</blockquote>
<p>접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 여기서 객체가 할당 해제되는 경우 Major GC가 발생했다고 한다.</p>
<p>Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행한다.</p>
<p>Major GC는 아래와 같은 방식에 따라 동작한다. GC 방식에 따라 처리가 달라진다.</p>
<ul>
<li>Serial GC</li>
<li>Parallel GC</li>
<li>Parallel Old GC(Parallel Compacting GC)</li>
<li>Concurrent Mark &amp; Sweep GC(이하 CMS) Java 9 부터 삭제.</li>
<li><p>G1(Garbage First) GC</p>
<p>참고 <a href="https://d2.naver.com/helloworld/1329" target="_blank" rel="noopener">Java Garbage Collection</a></p>
</li>
</ul>
<h2 id="Hash-Hasing-Collision-해결-방법"><a href="#Hash-Hasing-Collision-해결-방법" class="headerlink" title="Hash, Hasing Collision 해결 방법"></a>Hash, Hasing Collision 해결 방법</h2><p>?</p>
<h2 id="Syncronized-volatile-차이"><a href="#Syncronized-volatile-차이" class="headerlink" title="Syncronized, volatile 차이"></a>Syncronized, volatile 차이</h2><p>?</p>
<h2 id="Database-ACID"><a href="#Database-ACID" class="headerlink" title="Database ACID"></a>Database ACID</h2><p>트랜잭션은 ACID 성질이라고 하는 다음의 네 가지 성질로 설명된다.</p>
<p>A 원자성(Atomicity) 완료되지 않은 트랜잭션의 중간 상태를 데이터베이스에 반영하면 안된다.</p>
<p>C 일관성(Consistency) 고립된 트랜잭션의 수행이 데이터베이스의 일관성을 보존해야 한다</p>
<p>I 고립성(Isolation) 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다.</p>
<p>D 지속성(Durability) 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다.</p>
<h2 id="Database-Index"><a href="#Database-Index" class="headerlink" title="Database Index"></a>Database Index</h2><p>인덱스는 Clustered Index와 Nonclustered Index 두가지 종류로 나눌 수 있다.</p>
<p>Clustered Index는 테이블당 하나만 생성된다 일반적으로 PK에 생성된다. 지정한 열에 대해서 내용 자체가 정렬되어 있어 검색 시 빠르게 검색이 가능하다.</p>
<p>Nonclustered Index는 Clustered Index처럼 자동 정렬되지 않는다.</p>
<p>MySQL에서는 기본적으로 B-Tree 형태의 인덱스 구조를 사용하며 InnoDB 엔진은 B-Tree 구조를 기본으로 Clustered 인덱스 구조를 가짐 Clustered 인덱스의 Leaf Node에 모든 Row 데이터를 저장하여, Primary Key 혹은 Unique Key가 Clustered Key 역할을 수행하며 Clustered Key는 한 테이블에 1개만 존재</p>
<p>Primary/Unique Key 모두 선언되지 않은 테이블의 경우에는 6 byte의 Hidden Key를 생성 (rowid) Non-Clustered Key는 데이터의 물리적인 위치 대신 PK 값을 참조함</p>
<p>일단 index를 타지 않아 테이블 full scan하는 경우에 대해서 쿼리 튜닝이 필요하다. 쿼리 작성 시 explain으로 쿼리 실행 계획을 확인해서 index를 잘 타는지 full scan을 하지 않는지 체크하고 튜닝을 하자.</p>
<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>스트림 쪼개서 여러 리퀘스트 주는게 가능 서버 푸시 그래서 결국 빠르다.</p>
<p>빠르다 빨라</p>
<h2 id="OSI-7계층-TCP-IP-4계층"><a href="#OSI-7계층-TCP-IP-4계층" class="headerlink" title="OSI 7계층, TCP/IP 4계층"></a>OSI 7계층, TCP/IP 4계층</h2><p>OSI 7계층, 아래와 같다.</p>
<p><img src="https://sites.google.com/site/21herecomeputer/_/rsrc/1467128453476/2/tutorial-osi-7-layer-model.gif?height=2058&amp;width=2423" alt="osi 7 layerì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼"></p>
<p>여기서 <code>어플리케이션 계층, 표현 계층, 세션 층</code>을 통합해 하나의 어플리케이션 레이어로 구분하고 <code>데이터 링크 계층과 물리 계층</code>을 통합하여 네트워크 인터페이스 계층으로 통합한 것이 아래의 TCP/IP 계층 모델이다.</p>
<p><img src="assets/image-20180602211207249.png" alt="image-20180602211207249"></p>
<h2 id="Java-Collection-Framework"><a href="#Java-Collection-Framework" class="headerlink" title="Java Collection Framework"></a>Java Collection Framework</h2><p><img src="assets/image-20180602164520865.png" alt="image-20180602164520865"></p>
<p>Set은 중복을 허용하지 않음, List 는 중복 가능</p>
<p>HashSet은 입력 순서 보장 X LinkedHashSet 입력 순서 보장.</p>
<p>Vector 동기화 지원, ArrayList는 지원하지 않음</p>
<p><img src="http://shivasoft.in/blog/wp-content/uploads/2011/04/Java-Collection-interfaces-and-concrete-classes.jpg" alt="Java Collection interfaces and concrete classes"></p>
<p><img src="http://shivasoft.in/blog/wp-content/uploads/2011/04/JAVA-Map-interface-and-concrete-classes.jpg" alt="JAVA Map interface and concrete classes"></p>
<p>HashMap은 내부 hashing된 값에 따라 키 순서가 정해지므로 key는 특정 순서 없이 나온다.</p>
<p>TreeMap은 내부적으로 RedBlack Tree로 저장됨, 키값에 대한 Compartor 구현으로 정렬 순서를 바꿀수 있다. 정렬된 순서로 key 값이 나온다.</p>
<p>LinkedHashMap은 내부적으로 LinkedList, 입력 순서대로 key 값이 나온다.</p>
<p>참고 : <a href="http://pavankoppolu.blogspot.com/2012/03/collections-pictorial-representation.html" target="_blank" rel="noopener">JCF</a></p>
<h2 id="스프링에-적용된-디자인패턴"><a href="#스프링에-적용된-디자인패턴" class="headerlink" title="스프링에 적용된 디자인패턴"></a>스프링에 적용된 디자인패턴</h2><p>Decorator</p>
<p>Singleton</p>
<p>Proxy</p>
<p>데이터베이스<br>-SELECT, JOIN </p>
<p>소트, 진수변환 등 간단한 알고리즘 손코딩 준비</p>
<ul>
<li>디자인 패턴</li>
<li>스프링 구조, 원리 (edited)<br>이정도 보면 되냐고 포비한테 물어보니까<br>HTTP도 봐야된다네요<br>당연한걸 빼먹었네요</li>
</ul>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Interview/">Interview</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.png" alt="KyuNam"><a class="article__author__link" title="About KyuNam" rel="author">KyuNam</a><p class="article__author__desc">dev log</p><div class="article__author__socials"><a class="article__author__socials__item" href="https://github.com/tramyu" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="https://www.facebook.com/xmfpes" title="facebook" target="_blank"><i class="fa fa-facebook"></i></a><a class="article__author__socials__item" href="https://www.linkedin.com/feed/" title="linkedin" target="_blank"><i class="fa fa-linkedin"></i></a><a class="article__author__socials__item" href="https://www.instagram.com/" title="instagram" target="_blank"><i class="fa fa-instagram"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="KyuNam"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//kyunam-disqus-com.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-06-02T12:21:48.384Z"><meta itemprop="articleBody" content="String, StringBuilder, StringBuffer 차이
String

String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이 존재한다. 하지만 JDK 1.5 이후부터는 컴파일 타임에 StringBuilder로 변경한다고..."><meta itemprop="url" content="http://yoursite.com/etc/interview/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/etc/interview/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Devlog"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/internet.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/data/graph.png"><meta itemprop="url" content="http://yoursite.com/images/data/graph.png"><meta itemprop="width" content="1280"><meta itemprop="height" content="720"></div></article></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/etc/interview/">자바 기반 면접 질문 정리</a></li><li class="recent-posts__item"><a href="/java/spring/spring-boot-ref-doc-03/">Spring Boot</a></li><li class="recent-posts__item"><a href="/java/spring/spring-security/">Spring Security의 간략한 구조</a></li><li class="recent-posts__item"><a href="/algorithm/algorithm-20/">Codility 5-2 PassingCars</a></li><li class="recent-posts__item"><a href="/java/spring/spring-boot-angular-03/">스프링 부트와 Angular로 게시판 만들기 - 3. 로그인</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/">Backend</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/Java/">Java</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/Java/DesignPattern/">DesignPattern</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/Java/Spring/">Spring</a><span class="category-list-count">4</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/Hexo/">Hexo</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/">CS</a><span class="category-list-count">21</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CS/Algorithm/">Algorithm</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/Datastructure/">Datastructure</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/Javascript/">Javascript</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Interview/">Interview</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Tag cloud</h3><div class="tag-cloud"><a href="/tags/AbstractFactory/" style="font-size: 0.94rem;">AbstractFactory</a> <a href="/tags/Algorithm/" style="font-size: 1.5rem;">Algorithm</a> <a href="/tags/Graph/" style="font-size: 0.75rem;">Graph</a> <a href="/tags/Hexo/" style="font-size: 0.75rem;">Hexo</a> <a href="/tags/Interview/" style="font-size: 0.75rem;">Interview</a> <a href="/tags/Java/" style="font-size: 1.31rem;">Java</a> <a href="/tags/Javascript/" style="font-size: 0.94rem;">Javascript</a> <a href="/tags/Spring/" style="font-size: 1.13rem;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 0.75rem;">SpringBoot</a></div></div></div></div><p class="copyright"><small>© 2018 KyuNam<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>