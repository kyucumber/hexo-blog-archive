<!DOCTYPE html><html lang="kr"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>자바 기반 면접 질문 정리 | Devlog</title><link rel="stylesheet" href="/libs/spoqa-han-sans-kr/css/SpoqaHanSans-kr.css"><link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/highlights/dracula.css"><link rel="canonical" href="http://yoursite.com/etc/interview/"/>
<meta name="description" content="String, StringBuilder, StringBuffer 차이 String  String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이…">
<meta name="keywords" content="Interview">
<meta property="og:type" content="article">
<meta property="og:title" content="자바 기반 면접 질문 정리">
<meta property="og:url" content="http://yoursite.com/etc/interview/">
<meta property="og:site_name" content="Devlog">
<meta property="og:description" content="String, StringBuilder, StringBuffer 차이 String  String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이…">
<meta property="og:locale" content="kr">
<meta property="og:image" content="http://yoursite.com/images/data/graph.png">
<meta property="og:updated_time" content="2018-06-03T11:48:32.593Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="자바 기반 면접 질문 정리">
<meta name="twitter:description" content="String, StringBuilder, StringBuffer 차이 String  String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이…">
<meta name="twitter:image" content="http://yoursite.com/images/data/graph.png"><meta property="article:author" content="https://www.facebook.com/xmfpes"><meta property="twitter:label1" content="Published at"><meta property="twitter:data1" content="2018-06-02 21:30:00"><meta property="twitter:label2" content="Written by"><meta property="twitter:data2" content="KyuNam"><link rel="icon" href="/images/internet.png"><link rel="alternate" href="/atom.xml" type="application/atom+xml" title="Devlog"></head><body itemscope itemtype="https://schema.org/WebPage"><nav class="menu" id="menu"><div class="menu-inner"><div class="menu__left-area"><div class="menu__item"><a class="menu__item__link menu__item__link--brand" href="/" title="Home" rel="home"><img class="menu__item__link--brand__image" src="/images/internet.png" alt="Devlog"><span class="menu__item__link--brand__label">Devlog</span></a></div></div><div class="menu__right-area"><div class="menu__item"><a class="menu__item__link" href="/">Home</a></div><div class="menu__item"><a class="menu__item__link" href="/about">About</a></div><div class="menu__item"><a class="menu__item__link" href="/archives">Archives</a></div></div></div></nav><div class="page-background"></div><div class="content-container"><div class="content-outer"><div class="content-inner" itemscope itemtype="https://schema.org/Blog"><article class="article" id="article" itemscope itemtype="https://schema.org/BlogPosting"><h1 class="article__title" itemprop="headline">자바 기반 면접 질문 정리</h1><div class="article__meta"><time class="article__meta__time" datetime="2018-06-02T12:30:00.000Z" itemprop="datePublished">2018-06-02 21:30:00</time><div class="article__meta__categories"><a class="article__meta__categories__item" href="/categories/Interview/">Interview</a></div></div><div class="article__contents"><img src="/images/data/graph.png"/><h2 id="String-StringBuilder-StringBuffer-차이"><a href="#String-StringBuilder-StringBuffer-차이" class="headerlink" title="String, StringBuilder, StringBuffer 차이"></a>String, StringBuilder, StringBuffer 차이</h2><ul>
<li>String</li>
</ul>
<p>String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이 존재한다. 하지만 JDK 1.5 이후부터는 컴파일 타임에 StringBuilder로 변경한다고 한다.</p>
<ul>
<li>StringBuilder</li>
</ul>
<p>String에서 + 등으로 문자열 등을 concat하는 연산이 많은 경우 사용하는것이 좋다. 기존 String 문자들을 concat하는 경우 매번 새로운 String 인스턴스를 사용하기 때문에 성능상의 이슈 존재(JDK 1.5버전 부터는 내부적으로 StringBuilder를 이용하도록 변경되긴 했다.)</p>
<ul>
<li>StringBuffer</li>
</ul>
<p>StringBuffer는 Builder와 비교해서 thread-safe하다. (멀티 스레드 환경에서 동기화의 지원 여부가 다름.) 내부적으로 append 등 모든 메소드에 대해 synchronized 키워드가 붙어있다.</p>
<h2 id="Comparable-Comparator-차이"><a href="#Comparable-Comparator-차이" class="headerlink" title="Comparable, Comparator 차이"></a>Comparable, Comparator 차이</h2><p>정렬을 위해서 사용하는 인터페이스들인데 Comparable 인터페이스는 정렬 기준을 설정할 클래스가 직접 상속해 compareTo 메소드를 오버라이딩 해야 하며, Comparator는 직접 구현해서 Arrays.sort 같은 정렬 메소드에 인자로 넘겨 정렬 기준을 직접 설정해 줄 수 있다. </p>
<blockquote>
<p>Comparable</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Example</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Example o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Comparator</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">Arrays.sort(a, (a1, a2) -&gt; a2 - a1); <span class="comment">//FunctionalInterface로 Comparator 구현</span></span><br></pre></td></tr></table></figure>
<p>기본 sort는 오름차순이지만, 위처럼 Comparator를 구현해서 파라미터로 넘겨주면 내림차순으로 정렬이 가능.</p>
<h2 id="Java-Collection-Framework"><a href="#Java-Collection-Framework" class="headerlink" title="Java Collection Framework"></a>Java Collection Framework</h2><p><img src="image-20180603144347219.png" alt="Pasted Graphic 25.tiff"> </p>
<p>Set은 중복을 허용하지 않음, List 는 중복 가능</p>
<p>HashSet은 입력 순서 보장 X LinkedHashSet 입력 순서 보장.</p>
<p>Vector 동기화 지원, ArrayList는 지원하지 않음</p>
<p><img src="http://shivasoft.in/blog/wp-content/uploads/2011/04/Java-Collection-interfaces-and-concrete-classes.jpg" alt="Java Collection interfaces and concrete classes"></p>
<p><img src="http://shivasoft.in/blog/wp-content/uploads/2011/04/JAVA-Map-interface-and-concrete-classes.jpg" alt="JAVA Map interface and concrete classes"></p>
<p>HashMap은 내부 hashing된 값에 따라 키 순서가 정해지므로 key는 특정 순서 없이 나온다.</p>
<p>TreeMap은 내부적으로 RedBlack Tree로 저장됨, 키값에 대한 Compartor 구현으로 정렬 순서를 바꿀수 있다. 정렬된 순서로 key 값이 나온다.</p>
<p>LinkedHashMap은 내부적으로 LinkedList, 입력 순서대로 key 값이 나온다.</p>
<p>참고 : <a href="http://pavankoppolu.blogspot.com/2012/03/collections-pictorial-representation.html" target="_blank" rel="noopener">JCF</a></p>
<h2 id="스프링에-적용된-디자인패턴"><a href="#스프링에-적용된-디자인패턴" class="headerlink" title="스프링에 적용된 디자인패턴"></a>스프링에 적용된 디자인패턴</h2><p>Decorator</p>
<p>Singleton</p>
<p>Proxy</p>
<h2 id="JVM의-구조"><a href="#JVM의-구조" class="headerlink" title="JVM의 구조"></a>JVM의 구조</h2><p>JRE는 JVM과 Java API로 구성되어 있다.</p>
<p>자바 바이트코드는 JRE 위에서 동작하며, JRE는 JVM과 Java API로 구성되어 있다.</p>
<p>그 중 JVM은 자바 어플리케이션을 클래스 로더를 통해 읽어서 바이트코드를 해석하고 자바 API와 함께 실행하는 가장 중요한 역할을 담당하고 있다.</p>
<p>자바의 코드가 수행되는 과정은 Java Source(.java 파일)가 javac에 의해 Java Byte Code(.class 파일)로 변경되고 JVM의 클래스 로더가 컴파일된 자바 바이트코드를 런타임 데이터 영역에 로드하고 실행 엔진이 자바 바이트 코드를 수행하는 과정으로 이루어진다.</p>
<p><img src="https://d2.naver.com/content/images/2015/06/helloworld-1230-1.png" alt="image-20180602145758293"></p>
<blockquote>
<p> 클래스 로더(Class Loader)</p>
</blockquote>
<p>자바는 컴파일타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더이다. </p>
<blockquote>
<p> 런타임 데이터 영역(Runtime Data Areas)</p>
</blockquote>
<p>VM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 아래의 6가지 영역으로 나눌 수 있다.</p>
<ul>
<li><strong>스레드 별 하나씩 생성되는 영역</strong></li>
</ul>
<p><strong>PC Register</strong></p>
<p>스레드가 시작 될 때 생성, 현재 수행중인 JVM의 명령의 주소를 가진다.</p>
<p><strong>JVM Stack</strong></p>
<p>스레드 시작 시 생성, 스택 프레임을 저장하는 스택</p>
<p><em>Stack Frame</em></p>
<p>스택 프레임은 JVM 내에서 메서드가 수행될 때마다 하나의 스택 프레임이 생성되어 해당 스레드의 JVM 스택에 추가되고 메서드가 종료되면 스택 프레임이 제거된다. 각 스택 프레임은 지역 변수 배열(Local Variable Array), 피연산자 스택(Operand Stack), 현재 실행 중인 메서드가 속한 클래스의 런타임 상수 풀에 대한 레퍼런스를 갖는다. 지역 변수 배열, 피연산자 스택의 크기는 컴파일 시에 결정되기 때문에 스택 프레임의 크기도 메서드에 따라 크기가 고정된다.</p>
<p><em>지역 변수 배열</em></p>
<p>0부터 시작하는 인덱스를 가진 배열이다. 0은 메서드가 속한 클래스 인스턴스의 this 레퍼런스이고, 1부터는 메서드에 전달된 파라미터들이 저장되며, 메서드 파라미터 이후에는 메서드의 지역 변수들이 저장된다.</p>
<p><em>피연산자 스택</em></p>
<p>메서드의 실제 작업 공간이다. 각 메서드는 피연산자 스택과 지역 변수 배열 사이에서 데이터를 교환하고, 다른 메서드 호출 결과를 추가하거나(push) 꺼낸다(pop). 피연산자 스택 공간이 얼마나 필요한지는 컴파일할 때 결정할 수 있으므로, 피연산자 스택의 크기도 컴파일 시에 결정된다.</p>
<p><strong>Native Method Stack</strong></p>
<p>자바 외의 언어로 작성된 네이티브 코드를 위한 스택이다. 즉, JNI(Java Native Interface)를 통해 호출하는 C/C++ 등의 코드를 수행하기 위한 스택으로, 언어에 맞게 C 스택이나 C++ 스택이 생성된다.</p>
<ul>
<li><strong>모든 스레드가 공유하는 영역</strong></li>
</ul>
<p><strong>Heap Area</strong></p>
<p><em>**</em>인스턴스 또는 객체를 저장하는 공간으로 가비지 컬렉션 대상이다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다. 힙 구성 방식이나 가비지 컬렉션 방법 등은 JVM 벤더의 재량이다.</p>
<p><strong>Method Area</strong></p>
<p>메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 정보, Static 변수, 메서드의 바이트코드 등을 보관한다.</p>
<p>크게 코드 캐시 영역과 PermGen 영역으로 나눌 수 있는데 코드 캐시 영역은 캐시 영역은 컴파일 된 코드를 저장하는 데 사용하고 <code>PermGen은 Deprecated되고 Metaspace 영역으로 변경</code>되었다. Metaspace는 클래스 메타 데이터를 native 메모리에 저장하고 메모리가 부족할 경우 이를 자동으로 늘려준다.</p>
<p><strong>Runtime Constant Pool</strong></p>
<p>각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.</p>
<blockquote>
<p> 실행 엔진(Executiontion Engine)</p>
</blockquote>
<p>클래스 로더를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 실행된다. 실행 엔진은 자바 바이트코드를 명령어 단위로 읽어서 실행한다. CPU가 기계 명령어을 하나씩 실행하는 것과 비슷하다. 바이트코드의 각 명령어는 1바이트짜리 OpCode와 추가 피연산자로 이루어져 있으며, 실행 엔진은 하나의 OpCode를 가져와서 피연산자와 함께 작업을 수행한 다음, 다음 OpCode를 수행하는 식으로 동작한다.</p>
<p>아마 최신 버전에서 JVM의 많은 부분들이 변경되어서 위의 내용은 크게 의미가 없을 수도.. static 변수도 기존에 Method 영역에 올라가는건데 지금은 바뀌었다고 한다. 나중에 변경된 내용을 따로 정리해보면 좋을듯 일단은 위의 구조를 토대로 이해하고 넘어가자.</p>
<p>참고</p>
<p> <a href="https://d2.naver.com/helloworld/1230" target="_blank" rel="noopener">Naver d2 JVM Internal </a></p>
<h2 id="Override-Overload"><a href="#Override-Overload" class="headerlink" title="Override / Overload"></a>Override / Overload</h2><p>Overloading은 함수의 이름은 같으나 반환 타입이나 인자의 갯수, 인자의 타입이 다른 경우</p>
<p>Overriding 부모 클래스의 메소드를 자식 클래스에서 재정의 하는 것, 인터페이스의 메소드를 구현하는 경우</p>
<blockquote>
<p>Overloading</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(String a,String b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(a) + Integer.parseInt(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Overriding</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Example o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Comparator compareTo 메소드 구현</span></span><br></pre></td></tr></table></figure>
<h2 id="LinkedList와-ArrayList의-차이"><a href="#LinkedList와-ArrayList의-차이" class="headerlink" title="LinkedList와 ArrayList의 차이"></a>LinkedList와 ArrayList의 차이</h2><p>ArrayList는 검색에 유리한 구조, 삽입 삭제가 자주 일어나면 LinkedList를 사용하는것이 낫다.</p>
<p>ArrayList는 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해 아래와 같이 임시 배열을 생성해 데이터를 복사 하는 방법을 사용 하고 있기 때문에 삽입 삭제시 많은 복사가 일어나기 때문.</p>
<p><img src="./ArrayList.jpg" alt="arraylist-internal"></p>
<p>참고 </p>
<p><a href="http://www.codenuclear.com/how-arraylist-works-internally-java/" target="_blank" rel="noopener">How ArrayList Works Internally in Java</a></p>
<h2 id="Abstract-Class-Interface-차이점"><a href="#Abstract-Class-Interface-차이점" class="headerlink" title="Abstract Class, Interface 차이점"></a>Abstract Class, Interface 차이점</h2><p>추상 클래스는 상속을 통해 부모 클래스의 기능을 이용, 확장하기 위해 제공되며 다중 상속이 불가능하다.</p>
<p>인터페이스는 빈 껍데기 형태로 구현할 메소드를 정의하고, 강제해서 서브클래스들에 같은 동작을 보장하기 위해 제공되며 다중 상속이 가능하다. 자바 8 부터 인터페이스에도 default 메소드 구현이 가능하다.</p>
<blockquote>
<p>Abstract Class</p>
</blockquote>
<p>abstract 키워드가 붙거나 클래스 내 추상 메소드가 하나 이상 포함되는 클래스</p>
<p>만약 추상 클래스를 상속한다면, 추상 클래스에 존재하는 추상 메소드를 반드시 구현해주어야 하며 <code>extends</code>키워드를 사용한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">defaultGreeting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">defaultGreeting</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//아래 greeting 메소드를 구현 안 해주면 에러가 발생</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanGreeting</span> <span class="keyword">extends</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"american hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Interface</p>
</blockquote>
<p>추상 메소드만을 가지며, 메소드의 껍데기만 존재한다. 서브클래스는 무조건 모든 메소드들을 구현해야하며 <code>implements</code> 키워드를 사용한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">bye</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KoreanGreeting</span> <span class="keyword">implements</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Class와-Instance-Object"><a href="#Class와-Instance-Object" class="headerlink" title="Class와 Instance, Object"></a>Class와 Instance, Object</h2><h2 id="프로세스와-스레드의-차이"><a href="#프로세스와-스레드의-차이" class="headerlink" title="프로세스와 스레드의 차이"></a>프로세스와 스레드의 차이</h2><p>몰라</p>
<h2 id="Java의-접근-제어자"><a href="#Java의-접근-제어자" class="headerlink" title="Java의 접근 제어자"></a>Java의 접근 제어자</h2><p><strong>public</strong> 접근 제한이 없다.</p>
<p><strong>protected :</strong> 서브 클래스에서만 접근 가능</p>
<p><strong>default :</strong> 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지 내에서만 접근이 가능</p>
<p><strong>private :</strong> 자기 자신, 클래스 내부에서만 접근이 가능</p>
<h2 id="Java-Garbage-Collection"><a href="#Java-Garbage-Collection" class="headerlink" title="Java Garbage Collection"></a>Java Garbage Collection</h2><p>C++에서 new나 delete를 통해 메모리를 명시적으로 해제했지만 Java에서는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않고 가비지 컬렉터(Garbage Collector)가 이 역할을 대신한다.</p>
<p>더 이상 사용하지 않는 객체를 찾아서 지우는 역할을 하는것이 GC 이다.</p>
<p>Garbage Collection을 실행하면 JVM이 일시적으로 어플리케이션 실행을 멈추는데 이를 <code>stop-the-world</code> 라 한다.</p>
<p>stop-the-world가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다. GC 작업을 완료한 이후에야 중단했던 작업을 다시 시작한다. 어떤 GC 알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개의 경우 GC 튜닝이란 이 stop-the-world 시간을 줄이는 것이다.</p>
<p>GC는 아래의 두가지 가설을 토대로 만들어졌다.</p>
<ul>
<li>대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다.</li>
<li>오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.</li>
</ul>
<p>이러한 가설을 ‘weak generational hypothesis’라 한다. 이 가설의 장점을 최대한 살리기 위해서 HotSpot VM에서는 크게 2개로 물리적 공간을 나누었다. 둘로 나눈 공간이 <strong>Young 영역과 Old 영역</strong>이다.</p>
<p>영역별 데이터 흐름은 아래와 같다.</p>
<p><img src="./image-20180602160808763.png" alt="image-20180602160808763"></p>
<p>위의 Permanenet Generation 영역은 Method 영역에 포함된 부분이고.. Java 8부터 MetaSpace 영역으로 바뀌었다고 한다. 위 그림과 동일하게 적용되는지는 모르겠다. (PermGen 영역에서 일어나는 GC도 Major GC에 포함된다.)</p>
<blockquote>
<p>Young 영역</p>
</blockquote>
<p>새롭게 생성된 데이터 대부분이 Young Generation에 위치하며 여기서 객체가 할당 해제되는 경우 <strong>Minor GC</strong>가 발생했다고 한다.</p>
<ul>
<li>Eden 영역</li>
<li>Survivor 영역(2개)</li>
</ul>
<p>으로 나뉘며, Eden에서 살아남은 객체는 Survivor 으로 보내고, Survivor영역이 가득 차면 다른 Survivor 영역으로 보낸다. 이 과정에서 살아남은 객체는 Old 영역으로 이동하게 된다.</p>
<blockquote>
<p>Old 영역</p>
</blockquote>
<p>접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 여기서 객체가 할당 해제되는 경우 <strong>Major GC</strong>가 발생했다고 한다.</p>
<p>Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행한다.</p>
<p>Major GC는 아래와 같은 방식에 따라 동작한다. GC 방식에 따라 처리가 달라진다.</p>
<ul>
<li>Serial GC</li>
<li>Parallel GC</li>
<li>Parallel Old GC(Parallel Compacting GC)</li>
<li>Concurrent Mark &amp; Sweep GC(이하 CMS) Java 9 부터 삭제.</li>
<li><p>G1(Garbage First) GC</p>
<p>참고</p>
<p><a href="https://d2.naver.com/helloworld/1329" target="_blank" rel="noopener">Java Garbage Collection</a></p>
</li>
</ul>
<h2 id="Hash-Hasing-Collision-해결-방법"><a href="#Hash-Hasing-Collision-해결-방법" class="headerlink" title="Hash, Hasing Collision 해결 방법"></a>Hash, Hasing Collision 해결 방법</h2><p>Hash와 관련해서 자바에서는 HashMap, HashTable이 존재한다.</p>
<p>HashMap과 HashTable을 정의한다면, <code>키에 대한 해시 값을 사용하여 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 associate array</code>라고 할 수 있다. 이 associate array를 지칭하는 다른 용어가 있는데, 대표적으로 Map, Dictionary, Symbol Table 등이다.</p>
<blockquote>
<p>해시 함수</p>
</blockquote>
<p>임의의 길이의 데이터를 <strong>고정된 길이의 데이터</strong>로 매핑하는 함수이다. 그리고 그 데이터를 해시 값, 해시 코드 혹은 해시 체크섬이라고도 부른다.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Hash_table_4_1_1_0_0_1_0_LL.svg/300px-Hash_table_4_1_1_0_0_1_0_LL.svg.png" alt="í´ìí¨ì ê°ëë"></p>
<p>해시함수는 위처럼 key로 들어온 사람의 이름을 2자리의 해시코드로 바꾸어 준다. 이를 이용해 O(1)의 시간 복잡도로 key를 이용해 접근할 수 있는 구조를 가지게 된다.</p>
<p>위에서 John Smith와 Sandara Dee가 같은 해시 코드인 02로 매핑 된 것 처럼 해시 충돌이 발생할 수 있다.</p>
<blockquote>
<p>해시 충돌</p>
</blockquote>
<p>해시함수를 통해 얻은 해시코드 값이 두 개 이상 같은 경우 해시의 충돌이 발생한다.</p>
<p>충돌은 아무리 해시 함수를 잘 구현하더라도 필연적으로 발생할 수 밖에 없다.</p>
<p>이렇듯 발생하는 충돌에 대해서 해시 충돌이 발생하더라도 키-값 쌍 데이터를 잘 저장하고 조회할 수 있게 하는 방식에는 대표적으로 두가지가 존재하는데 하나는 <strong>Open Addressing</strong>이고, 다른 하나는 <strong>Separate Chaining</strong>이다.</p>
<p><img src="./image-20180603152806610.png" alt="image-20180603152806610"></p>
<p>Open Addressing은 데이터를 삽입하려는 해시 버킷이 이미 사용 중인 경우 다른 해시 버킷에 해당 데이터를 삽입하는 방식이다. 데이터를 저장/조회할 해시 버킷을 찾을 때에는 Linear Probing, Quadratic Probing 등의 방법을 사용한다.</p>
<p>Separate Chaining에서 각 배열의 인자는 인덱스가 같은 해시 버킷을 연결한 링크드 리스트의 첫 부분(head)이다.</p>
<p><em>Java HashMap에서 사용하는 방식은 Separate Channing이다. Open Addressing은 데이터를 삭제할 때 처리가 효율적이기 어려운데, HashMap에서 remove() 메서드는 매우 빈번하게 호출될 수 있기 때문이다. 둘 모두 Worst Case O(M) 이며 자세한 설명한 생략한다.</em></p>
<p>참고 </p>
<p><a href="https://d2.naver.com/helloworld/831311" target="_blank" rel="noopener">Java HashMap은 어떻게 동작하는가? D2</a></p>
<p><a href="https://tech.wheejuni.com/2018/04/13/morningcs-hash/" target="_blank" rel="noopener">봄이네집 - 해시 함수</a></p>
<h2 id="Syncronized-volatile-차이"><a href="#Syncronized-volatile-차이" class="headerlink" title="Syncronized, volatile 차이"></a>Syncronized, volatile 차이</h2><p>?</p>
<h2 id="Database-ACID"><a href="#Database-ACID" class="headerlink" title="Database ACID"></a>Database ACID</h2><p>트랜잭션은 ACID 성질이라고 하는 다음의 네 가지 성질로 설명된다.</p>
<p>A 원자성(Atomicity) 완료되지 않은 트랜잭션의 중간 상태를 데이터베이스에 반영하면 안된다.</p>
<p>C 일관성(Consistency) 고립된 트랜잭션의 수행이 데이터베이스의 일관성을 보존해야 한다</p>
<p>I 고립성(Isolation) 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다.</p>
<p>D 지속성(Durability) 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다.</p>
<h2 id="Database-Index"><a href="#Database-Index" class="headerlink" title="Database Index"></a>Database Index</h2><p>인덱스는 Clustered Index와 Nonclustered Index 두가지 종류로 나눌 수 있다.</p>
<p>Clustered Index는 테이블당 하나만 생성된다 일반적으로 PK에 생성된다. 지정한 열에 대해서 내용 자체가 정렬되어 있어 검색 시 빠르게 검색이 가능하다.</p>
<p>Nonclustered Index는 Clustered Index처럼 자동 정렬되지 않는다.</p>
<p>MySQL에서는 기본적으로 B-Tree 형태의 인덱스 구조를 사용하며 InnoDB 엔진은 B-Tree 구조를 기본으로 Clustered 인덱스 구조를 가짐 Clustered 인덱스의 Leaf Node에 모든 Row 데이터를 저장하여, Primary Key 혹은 Unique Key가 Clustered Key 역할을 수행하며 Clustered Key는 한 테이블에 1개만 존재</p>
<p>Primary/Unique Key 모두 선언되지 않은 테이블의 경우에는 6 byte의 Hidden Key를 생성 (rowid) Non-Clustered Key는 데이터의 물리적인 위치 대신 PK 값을 참조함</p>
<p>일단 index를 타지 않아 테이블 full scan하는 경우에 대해서 쿼리 튜닝이 필요하다. 쿼리 작성 시 explain으로 쿼리 실행 계획을 확인해서 index를 잘 타는지 full scan을 하지 않는지 체크하고 튜닝을 하자.</p>
<h2 id="OSI-7계층-TCP-IP-4계층"><a href="#OSI-7계층-TCP-IP-4계층" class="headerlink" title="OSI 7계층, TCP/IP 4계층"></a>OSI 7계층, TCP/IP 4계층</h2><p>OSI 7계층, 아래와 같다.</p>
<p><img src="./osi.gif" alt="osi 7 layer"></p>
<p>여기서 <code>어플리케이션 계층, 표현 계층, 세션 층</code>을 통합해 하나의 어플리케이션 레이어로 구분하고 <code>데이터 링크 계층과 물리 계층</code>을 통합하여 네트워크 인터페이스 계층으로 통합한 것이 TCP/IP 계층 모델이다.</p>
<p><a href="http://www.naver.com" target="_blank" rel="noopener">www.naver.com</a> 을 호출했을 때의 네트워크의 흐름 TCP/IP 계층 모델에 맞춰서 설명해보자.</p>
<blockquote>
<p>송신지</p>
</blockquote>
<p><strong>어플리케이션 계층(HTTP)</strong></p>
<p>브라우저에서 <code>www.naver.com</code> URL을 호출한다.</p>
<p>클라이언트의 웹 브라우저에서 URL 입력 시 브라우저는 DNS를 이용해 웹사이트가 있는 서버의 진짜 주소(ip address)를 찾는다. 그리고 브라우저는 서버에 HTTP 요청 메세지를 전송한다.</p>
<p><strong>트랜스포트 계층(TCP, UDP)</strong></p>
<p>어플리케이션 계층의 데이터를 받아 세그먼트(TCP 기준) 단위로 분할하고 전송한다. 세그먼트는 분할된 데이터에 TCP 헤더가 붙은 형태로 구성되며 TCP 헤더에는 송신지 포트 번호, 수신지 포트 번호 등이 포함되어 있다.</p>
<p><strong>인터넷 계층(IP)</strong></p>
<p>네트워크 계층에서는 데이터가 인터넷 상에 원하는 주소로 이동할 수 있도록 IP 패킷의 형태로 만들어진다. IP 패킷의 IP 헤더에는 송신지와 수신지의 IP 어드레스 정보 등이 들어있다.</p>
<p>데이터를 목적지까지 전달하기 위해 다음 네트워크의 경로를 찾고, 경로상의 라우터에게 데이터 전달을 위임한다. 이런 일련의 과정을 <strong>라우팅</strong>이라고 하고 라우팅을 통해 목적지까지 전달되었으면, 네트워크 인터페이스 계층으로 데이터를 보내게 된다.</p>
<p><em>라우터는 라우터 내부의 라우팅 테이블을 이용해 라우팅을 함. 라우팅 테이블은 목적지 호스트가 속한 네트워크 정보와 그 네트워크 도달을 위해 경유해야하는 라우터 정보가 들어있다.</em></p>
<p><strong>네트워크 인터페이스 계층</strong></p>
<p>이더넷 카드(LAN card)를 통해 패킷을 내보낸다.</p>
<p><em>상위 계층이 하드웨어 동작에 대해 신경쓰지 않고 동작할 수 있도록 소프트웨어, 하드웨어 적인 부분을 담당하는 계층이다.</em></p>
<p><em>기존 7 Layer에서는 소프트웨어적인 부분이 데이터 링크 계층, 하드웨어와 관련된 부분이 물리 계층으로 구분된다.</em></p>
<blockquote>
<p>수신지</p>
</blockquote>
<p><strong>네트워크 인터페이스 계층</strong></p>
<p><a href="http://www.naver.com의" target="_blank" rel="noopener">www.naver.com의</a> 서버의 이더넷 카드로 TCP/IP 패킷을 전달받는다. 받은 패킷을 인터넷 계층으로 보낸다.</p>
<p><strong>인터넷 계층</strong></p>
<p>데이터를 받아 IP 패킷을 분석하고, 이 패킷이 어디에서 왔으며, 그 도착지가 어디인지를 판단하게 된다. 자신이 수신해야하는 데이터라고 판단이 되면 트랜스포트 계층으로 데이터를 전달한다.</p>
<p><strong>트랜스포트 계층</strong></p>
<p>도달하지 못한 패킷이 있다면 재 전송을 요청하고 메세지를 검사한 뒤 어플리케이션 계층으로 전달한다. 할당된 포트 번호와 수신지의 포트 번호를 확인 해 HTTP 요청이면 80번 포트로 전달한다.</p>
<p><strong>어플리케이션 계층</strong></p>
<p>HTTP 프로토콜에 따른 요청에 대한 응답을 트랜스포트 계층으로 전송한다.</p>
<h2 id="TCP와-UDP의-차이점"><a href="#TCP와-UDP의-차이점" class="headerlink" title="TCP와 UDP의 차이점"></a>TCP와 UDP의 차이점</h2><p>TCP와 UDP는 둘다 Transport 계층의 프로토콜로 데이터 전달을 위한 프로토콜.</p>
<p>신뢰성 있는 연결 보장의 차이 그리고 그에 따른 속도 차이가 존재. TCP는 전송 실패시 재전송 등.. 3way handshaking 등으로 데이터 정확한 전달을 보장하므로 UDP에 비해 느리다.</p>
<p>TCP는 데이터의 정확한 전달을 중시한다. 3way handshaking을 통해 커넥션을 먼저 연결하고, 커넥션이 맺어진 이후에 데이터를 전송할 수 있다. 데이터 전송이 끝나면 4 way handshaking을 통해 커넥션을 종료한다.</p>
<p>UDP의 경우에는 TCP에서 지원하는 데이터 재전송이나 커넥션 연결 등을 생략하기 때문에 전송 과정에서 데이터의 손실이 발생할 수 있다.  UDP 프로토콜은 VoIP와 같은 음성 서비스, 동영상 스트리밍 등에 사용한다.</p>
<h2 id="HTTP-Request-Response-Header-methods-Status-Code"><a href="#HTTP-Request-Response-Header-methods-Status-Code" class="headerlink" title="HTTP Request, Response Header, methods, Status Code"></a>HTTP Request, Response Header, methods, Status Code</h2><p>HTTP는 Stateless 프로토콜 현재 요청에서는 이전 요청에서 수행된 작업을 알지 못한다.</p>
<blockquote>
<p>URL</p>
</blockquote>
<h4 id="Uniform-Resource-Locator-URL"><a href="#Uniform-Resource-Locator-URL" class="headerlink" title="Uniform Resource Locator (URL)"></a>Uniform Resource Locator (URL)</h4><p>HTTP 요청을 보내기 위해서 URL을 사용한다.</p>
<p>URL (Uniform Resource Locator)은 웹을 통해 리소스를 고유하게 식별하는 데 사용하며 구조는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protocol://hostname:port/path-and-file-name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HTTP Request</p>
</blockquote>
<p><img src="./image-20180603203000371.png" alt="image-20180603203000371"></p>
<p><strong>Request Message Header</strong></p>
<ul>
<li><strong>Request Line</strong></li>
</ul>
<p>요청이나 프로토콜 버전, 디렉토리 파일 명 등이 들어가며</p>
<ul>
<li><strong>Request Headers</strong></li>
</ul>
<p>컨텐츠의 길이, 인코딩 정보나 언어 정보 등 다양한 정보들이 헤더에 들어간다.</p>
<p><strong>CRLF</strong></p>
<p>바디와 헤더의 구분을 위해 들어가는 CRLF</p>
<p><strong>Request Message Body</strong></p>
<p>Body 영역, 사실 위와 같은 GET 요청에는 Message Body가 없다.</p>
<blockquote>
<p>HTTP Response</p>
</blockquote>
<p><img src="./image-20180603203355021.png" alt="image-20180603203355021"></p>
<p><strong>Response Message Header</strong></p>
<ul>
<li><strong>Status Line</strong></li>
</ul>
<p>프로토콜 버전과 상태 정보, 상태 코드가 지금 예에서는 200으로 OK를 나타낸다.</p>
<ul>
<li><strong>Response Headers</strong></li>
</ul>
<p>파일 갱신 날짜, 크기 등등이 들어간다.</p>
<p><strong>CRLF</strong></p>
<p>바디와 헤더의 구분을 위해 들어가는 CRLF</p>
<p><strong>Response Message Body</strong></p>
<p>HTML 파일의 내용이 들어간다.</p>
<blockquote>
<p>HTTP Request Methods</p>
</blockquote>
<p>클라이언트에서는 아래의 HTTP Request Method를 이용해 HTTP 서버로 요청을 보낼 수 있다.</p>
<p><strong>GET</strong></p>
<p>GET 요청을 통해 서버에서 리소스를 가져올 수 있다.</p>
<p><strong>HEAD</strong></p>
<p>클라이언트는 HEAD 요청을 사용하여 GET 요청이 얻었을 헤더를 얻을 수 있다. 헤더에는 데이터의 최종 수정 날짜가 포함되어 있으므로 이 데이터를 사용하여 로컬 캐시 복사본을 검사 할 수 있다.</p>
<p><strong>POST</strong></p>
<p>서버에 데이터를 Create 하거나 할 때 사용 ex) 게시글 등록, 회원 가입</p>
<p><strong>PUT</strong></p>
<p>서버 데이터 수정 시 사용(전체 변경 시)</p>
<p><strong>PATCH</strong></p>
<p>서버 데이터 수정 시 (일부 변경)</p>
<p><strong>DELETE</strong></p>
<p>웹 서버에 데이터 Delete 요청 할 때 사용</p>
<p>그 외에도.. TRACE, OPTIONS, CONNECT.. 가 있다고 하는데 써본적도 없고 중요하지 않은것 같아서 패스</p>
<blockquote>
<p>Status Code</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">상태 코드</th>
<th style="text-align:center">의미</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100 Continue</td>
<td style="text-align:center">서버가 헤더를 받았고, 바디를 기다리고 있음</td>
</tr>
<tr>
<td style="text-align:center">101 Switching Protocols</td>
<td style="text-align:center">클라이언트가 서버에서 프로토콜 변경 요청, 서버 수락</td>
</tr>
<tr>
<td style="text-align:center">200 OK</td>
<td style="text-align:center">요청 성공, 요청 결과 데이터를 응답으로 보냄</td>
</tr>
<tr>
<td style="text-align:center">201 Created</td>
<td style="text-align:center">요청이 성공했고 새로 만들어진 URL을 응답으로 보냈음.</td>
</tr>
<tr>
<td style="text-align:center">301 Moved Permanently</td>
<td style="text-align:center">요청한 내용이 다른 경로로 옮겨졌으므로 다른 경로로 요청</td>
</tr>
<tr>
<td style="text-align:center">302 Found</td>
<td style="text-align:center">요청한 내용이 다른 경로로 옮겨졌음. 임시로 옮겨진 것이라 이후에도 동일한 경로로 요청</td>
</tr>
<tr>
<td style="text-align:center">304 Not Modifed</td>
<td style="text-align:center">요청 내용은 갱신되지 않았음.</td>
</tr>
<tr>
<td style="text-align:center">400 Bad Request</td>
<td style="text-align:center">요청에 문제가 있음</td>
</tr>
<tr>
<td style="text-align:center">403 Forbidden</td>
<td style="text-align:center">요청 내용 접근 금지</td>
</tr>
<tr>
<td style="text-align:center">404 Not Found</td>
<td style="text-align:center">요청한 내용을 찾을 수 없음</td>
</tr>
</tbody>
</table>
<p>참고</p>
<p><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="noopener">HTTP</a></p>
<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>스트림 쪼개서 여러 리퀘스트 주는게 가능 서버 푸시 그래서 결국 빠르다.</p>
<p>빠르다 빨라</p>
<p>데이터베이스<br>-SELECT, JOIN </p>
<p>소트, 진수변환 등 간단한 알고리즘 손코딩 준비</p>
<ul>
<li>디자인 패턴</li>
<li>스프링 구조, 원리 (edited)<br>이정도 보면 되냐고 포비한테 물어보니까<br>HTTP도 봐야된다네요<br>당연한걸 빼먹었네요</li>
</ul>
</div><div class="article__tags"><a class="article__tags__item" href="/tags/Interview/">Interview</a></div><div class="article__author" itemscope itemprop="author" itemtype="https://schema.org/Person"><img class="article__author__image" src="/images/profile.png" alt="KyuNam"><a class="article__author__link" title="About KyuNam" rel="author">KyuNam</a><p class="article__author__desc">dev log</p><div class="article__author__socials"><a class="article__author__socials__item" href="https://github.com/tramyu" title="github" target="_blank"><i class="fa fa-github"></i></a><a class="article__author__socials__item" href="https://www.facebook.com/xmfpes" title="facebook" target="_blank"><i class="fa fa-facebook"></i></a><a class="article__author__socials__item" href="https://www.linkedin.com/feed/" title="linkedin" target="_blank"><i class="fa fa-linkedin"></i></a><a class="article__author__socials__item" href="https://www.instagram.com/" title="instagram" target="_blank"><i class="fa fa-instagram"></i></a><a class="article__author__socials__item" href="/atom.xml" title="rss" target="_blank"><i class="fa fa-rss"></i></a></div><meta itemprop="name" content="KyuNam"></div><div class="sharer" id="sharer"><div class="sharer-inner"><div class="sharer__right"><button class="sharer__item" id="sharer-facebook"><i class="fa fa-facebook-official"></i></button><button class="sharer__item" id="sharer-twitter"><i class="fa fa-twitter"></i></button><button class="sharer__item" id="sharer-pinterest"><i class="fa fa-pinterest"></i></button><button class="sharer__item" id="sharer-pocket"><i class="fa fa-get-pocket"></i></button></div></div></div><!-- Disqus Code--><div id="disqus_thread"></div><script>(function() {
  var d = document, s = d.createElement('script');
  s.src = '//kyunam-disqus-com.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Enable JavaScript to see comments.</noscript><!-- Meta Tags for Structured Data--><meta itemprop="dateModified" content="2018-06-03T11:48:32.593Z"><meta itemprop="articleBody" content="String, StringBuilder, StringBuffer 차이
String

String 클래스는 Immutable 객체이기 때문에 + 등 concat 연산 시 원본을 변경하지 않고 새로운 String 인스턴스를 생성해야 하는 단점이 존재한다. 하지만 JDK 1.5 이후부터는 컴파일 타임에 StringBuilder로 변경한다고..."><meta itemprop="url" content="http://yoursite.com/etc/interview/"><meta itemprop="mainEntityOfPage" content="http://yoursite.com/etc/interview/"><div itemscope itemtype="https://schema.org/Organization" itemprop="publisher"><meta itemprop="name" content="Devlog"><div itemscope itemprop="logo" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="http://yoursite.com/images/internet.png"></div></div><div itemscope itemtype="https://schema.org/ImageObject" itemprop="image"><meta itemprop="contentUrl" content="http://yoursite.com/images/data/graph.png"><meta itemprop="url" content="http://yoursite.com/images/data/graph.png"><meta itemprop="width" content="1280"><meta itemprop="height" content="720"></div></article></div></div></div><footer id="footer"><div class="widgets"><div class="widgets-inner"><!-- Jade doesn't support dynamic inclusion with `each`.--><!-- So, I just hard coded the file names that will be included.--><div class="widgets__item"><h3 class="widgets__item__heading">Recent posts</h3><ul class="recent-posts"><li class="recent-posts__item"><a href="/etc/interview/">자바 기반 면접 질문 정리</a></li><li class="recent-posts__item"><a href="/java/spring/spring-boot-ref-doc-03/">Spring Boot</a></li><li class="recent-posts__item"><a href="/java/spring/spring-security/">Spring Security의 간략한 구조</a></li><li class="recent-posts__item"><a href="/algorithm/algorithm-20/">Codility 5-2 PassingCars</a></li><li class="recent-posts__item"><a href="/java/spring/spring-boot-angular-03/">스프링 부트와 Angular로 게시판 만들기 - 3. 로그인</a></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Categories</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/">Backend</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/Java/">Java</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/Java/DesignPattern/">DesignPattern</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/Java/Spring/">Spring</a><span class="category-list-count">4</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">Blog</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/Hexo/">Hexo</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/">CS</a><span class="category-list-count">21</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CS/Algorithm/">Algorithm</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/Datastructure/">Datastructure</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/Javascript/">Javascript</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Interview/">Interview</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li></ul></div><div class="widgets__item"><h3 class="widgets__item__heading">Tag cloud</h3><div class="tag-cloud"><a href="/tags/AbstractFactory/" style="font-size: 0.94rem;">AbstractFactory</a> <a href="/tags/Algorithm/" style="font-size: 1.5rem;">Algorithm</a> <a href="/tags/Graph/" style="font-size: 0.75rem;">Graph</a> <a href="/tags/Hexo/" style="font-size: 0.75rem;">Hexo</a> <a href="/tags/Interview/" style="font-size: 0.75rem;">Interview</a> <a href="/tags/Java/" style="font-size: 1.31rem;">Java</a> <a href="/tags/Javascript/" style="font-size: 0.94rem;">Javascript</a> <a href="/tags/Spring/" style="font-size: 1.13rem;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 0.75rem;">SpringBoot</a></div></div></div></div><p class="copyright"><small>© 2018 KyuNam<br>Powered by <a href="https://hexo.io" rel="external" target="_blank">Hexo</a>, Theme by <a href="https://github.com/hyunseob" rel="external" target="_blank">HyunSeob</a></small></p></footer><script src="/js/sharer.min.js"></script></body></html>